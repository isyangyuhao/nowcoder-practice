数据库
=======================

* __SQL语言允许使用通配符进行字符串匹配的操作,其中‘%’可以表示（D)__

  A. 零个字符

  B. 1个字符

  C. 多个字符

  D. 以上都可以

> * %: 替代一个或多个字符
> * -: 代替一个字符
> * [charlist]: 字符列中的任何单一字符
> * [!charlist] or [^charlist]: 不在字符列中的任何单一字符

- - - - -

* __下列有关MySQL数据库中的NULL值,说法正确的是(D)__

  A. NULL与它本身的比较可以使用=,<>或!=

  B. NULL是"有数据的"

  C. NULL与0的比较可以使用=,<>或!=

  D. NULL是"无数据"或"未知数据"

> ### 空值与NULL的概念
> * 空值不占用控件,判断空字符用"="or"<>"来进行处理
> * NULL值是未知的,且占用空间,不走索引;判断NULL用IS NULL或者IS NOT NULL,SQL语句函数中可以使用ifnull()函数来进行处理.
> 在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中 

- - - - -

* __分布式事务处理的特性包括哪些(持久性、隔离性、原子性、一致性)__

  A. 持久性

  B. 隔离性

  C. 原子性

  D. 一致性

> ###事务的四大特征
> 1. 原子性(Atomicity):事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行
> 2. 一致性(Consistency):几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致
> 3. 隔离性(Isolation):事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的
> 4. 持久性(Durability):对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障

- - - - -

* __把对关系 SC 的属性 GRADE 的修改权授予用户 ZHAO 的 SQL 语句是：(D)__

  A. GRANT UPDATE ON SC TO ZHAO

  B. GRANT GRADE ON SC TO ZHAO

  C. GRANT UPDATE ON SC (GRADE) TO ZHAO

  D. GRANT UPDATE (GRADE) ON SC TO ZHAO

> ### 授权
> __授权的语法为: `grant 权限 (列名) on table to 用户名 `__
> e.g. `GRANT SELECT(USERNAME) ON USER TO YANG`

- - - - -


* __假设MySQL数据库表:__

  `create table T{
  k int unsigned not null auto_increment,
  a date,
  b varchar(24),
  c int,d varchar(24),
  primary key(k),unique key a_index (a DESC,b DESC),
  key k1(b),key k2(c),key k3(d));`

  如下哪些sql语句查询能较好的利用索引?(D)

  A. select b from WHERE b like 'aaa%';

  B. select a,b from T WHERE a='2015-10-25' ORDER BY b ASC,c ASC;

  C. select a,b,c from T WHERE a='2015-10-25' ORDER BY b ASC;

  D. select a,b,c from T WHERE a='2015-10-25' ORDER BY a,b;

> ### 索引
> 建立索引在进行数据库操作的时候不需要全盘一条条的扫描，删选出符合的记录，索引内部自己有一套优化算法，因此借助索引来对数据库进行操作可以提高查询的效率
> ### 使用索引效率不高的场景
> * 使用了运算符!=，以及关键字not in, not exist等，认为产生的结果集很大，往往导致引擎不走索引而是走全盘扫描
> * 对索引字段使用了函数，如where substr(name, 1, 3)=‘mark’， 导致索引无效
> * 使用like和通配符，第一个字符是%将导致索引失效，如where name like "%ark“ 
> ### order by与索引
> 如果order by中的字段有建立索引，同时：
> * 该字段没有出现在where中，则在排序的时候需要正常排序，默认order by是升序排序, 故索引没有对排序产生有利帮助 （B,C错误）
> * 该字段同时同时出现在where中，则在获取记录后不进行排序，而是直接利用索引， 效率变高。（D正确）

- - - - -

* __下面有关事务隔离级别说法正确的是?(ABCD)__

  A. 串行读(Serializable):完全串行化的读,每次读都需要获得表级共享锁,读写相互都会阻塞

  B. 未提交读(Read Uncommitted):允许脏读,也就是可能读取到其他会话中未提交事务修改 的数据

  C. 提交读(Read Committed):只能读取到已经提交的数据

  D. 可重复读(Repeated Read):在同一个事务内的查询都是事务开始时刻一致的
  
> ### 出现的问题
> 1. 更新丢失:一个事务的更新覆盖了另一个事务的更新。 
> 2. 脏读:一个事务读取了另一个事务未提交的数据。 
> 3. 不可重复读:一个事务两次读取同一个数据，两次读取的数据不一致。 
> 4. 幻象读:一个事务两次读取一个范围的记录，两次读取的记录数不一致。
>
> ### 事务的隔离级别
> 1. 未提交读:一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而 且能看到其他事务没有提交的对已有记录的更新。
> 2. 已提交读:一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新。
> 3. 可重复读:一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他其他事务对已有记录的更新。
> 4. 串行化:一个事务在执行过程中完全看不到其他事务对数据库所做的更新。（事务执行的时候不允许别的事务并发执行。事务串行化执行，事务只能一个接着一个地执行，而不能并发执行）
>
> ### 隔离级别与对应出现的状况
>
> | | 丢失更新 | 脏读 | 非重复读 | 覆盖更新 | 幻想读 |
> |:---:|:---:|:---:|:---:|:---:|:---:|
> | 未提交读 | Y | Y | Y | Y | Y |
> | 未提交读 | N | N | Y | Y | Y |
> | 未提交读 | N | N | N | N | Y |
> | 未提交读 | N | N | N | N | N |

_2017/2/26_
